From 9df674776cbe2074ff6535a4e61d3c54e217872a Mon Sep 17 00:00:00 2001
From: Xi Ruoyao <xry111@xry111.site>
Date: Mon, 23 Jun 2025 20:21:11 +0800
Subject: [PATCH 16/63] loonggpu: Implement client-based fbdev emulation

Implement fbdev emulation on top of struct drm_client and its helpers.
Replaces ad-hoc interfaces for restoring and closing fbdev emulation with
per-client callbacks for hotplugging, restoring and unregistering.

A single function, gsgpu_fbdev_setup(), starts fbdev emulation after
the DRM device has been registered. Hence, fbdev acts like a regular
DRM client.

The setup call prepares the fbdev emulation and invokes connector
hotplugging. The first successful hotplug event initializes fbdev
emulation with a framebuffer, device file, etc.

Unregistering depends on the hotplug status. Fully initialized emulation
is cleaned up through drm_fb_helper_unregister_info() and fb_destroy.
For prepared-only setups, unregistering unprepares the emulation and
releases all resources. In both cases, fbdev emulation will be cleaned
up.

Following up the reference implementation change.

Link: https://git.kernel.org/torvalds/c/e317a69fe891
Signed-off-by: Xi Ruoyao <xry111@xry111.site>
---
 include/loonggpu_mode.h    |   3 +-
 loonggpu/loonggpu_device.c |  13 ++---
 loonggpu/loonggpu_drv.c    |   8 ++-
 loonggpu/loonggpu_fb.c     | 112 ++++++++++++++++++++++++++-----------
 4 files changed, 90 insertions(+), 46 deletions(-)

diff --git a/include/loonggpu_mode.h b/include/loonggpu_mode.h
index 87fea79..b0b75d3 100644
--- a/include/loonggpu_mode.h
+++ b/include/loonggpu_mode.h
@@ -160,8 +160,7 @@ int loonggpu_display_framebuffer_init(struct drm_device *dev,
 				   const struct drm_mode_fb_cmd2 *mode_cmd,
 				   struct drm_gem_object *obj);
 
-int loonggpu_fbdev_init(struct loonggpu_device *adev);
-void loonggpu_fbdev_fini(struct loonggpu_device *adev);
+void loonggpu_fbdev_setup(struct loonggpu_device *adev);
 void loonggpu_fbdev_set_suspend(struct loonggpu_device *adev, int state);
 bool loonggpu_fbdev_robj_is_fb(struct loonggpu_device *adev, struct loonggpu_bo *robj);
 int loonggpu_align_pitch(struct loonggpu_device *adev, int width, int bpp, bool tiled);
diff --git a/loonggpu/loonggpu_device.c b/loonggpu/loonggpu_device.c
index a838973..d480ac6 100644
--- a/loonggpu/loonggpu_device.c
+++ b/loonggpu/loonggpu_device.c
@@ -1433,14 +1433,12 @@ int loonggpu_device_init(struct loonggpu_device *adev,
 		max_MBps = 8; /* Allow 8 MB/s. */
 	/* Get a log2 for easy divisions. */
 	adev->mm_stats.log2_max_MBps = ilog2(max(1u, max_MBps));
-	if (adev->family_type != CHIP_NO_GPU) {
-		r = loonggpu_ib_pool_init(adev);
-		if (r) {
-			dev_err(adev->dev, "IB initialization failed (%d).\n", r);
-			goto failed;
-		}
+
+	r = loonggpu_ib_pool_init(adev);
+	if (r) {
+		dev_err(adev->dev, "IB initialization failed (%d).\n", r);
+		goto failed;
 	}
-	loonggpu_fbdev_init(adev);
 
 	r = loonggpu_pm_sysfs_init(adev);
 	if (r)
@@ -1520,7 +1518,6 @@ void loonggpu_device_fini(struct loonggpu_device *adev)
 
 	loonggpu_ib_pool_fini(adev);
 	loonggpu_fence_driver_fini(adev);
-	loonggpu_fbdev_fini(adev);
 	r = loonggpu_device_ip_fini(adev);
 	if (adev->firmware.gpu_info_fw) {
 		release_firmware(adev->firmware.gpu_info_fw);
diff --git a/loonggpu/loonggpu_drv.c b/loonggpu/loonggpu_drv.c
index 58d98c9..d6087b4 100644
--- a/loonggpu/loonggpu_drv.c
+++ b/loonggpu/loonggpu_drv.c
@@ -650,11 +650,14 @@ retry_init:
 		/* Don't request EX mode too frequently which is attacking */
 		msleep(5000);
 		goto retry_init;
-	} else if (ret)
+	}
+
+	if (ret)
 		goto err_pci;
 
+	loonggpu_fbdev_setup(dev->dev_private);
 
-	return ret;
+	return 0;
 
 err_pci:
 	pci_disable_device(pdev);
@@ -743,7 +746,6 @@ static struct drm_driver kms_driver = {
 		| DRIVER_RENDER | DRIVER_ATOMIC,
 	.open = loonggpu_driver_open_kms,
 	.postclose = loonggpu_driver_postclose_kms,
-	lg_drm_driver_set_lastclose
 	.unload = loonggpu_driver_unload_kms,
 	lg_drm_driver_get_vblank_counter_setting(loonggpu_get_vblank_counter_kms)
 	lg_drm_driver_get_vblank_timestamp_setting()
diff --git a/loonggpu/loonggpu_fb.c b/loonggpu/loonggpu_fb.c
index 4ee4c91..7f40eae 100644
--- a/loonggpu/loonggpu_fb.c
+++ b/loonggpu/loonggpu_fb.c
@@ -67,14 +67,17 @@ static void loonggpu_fbdev_fb_destroy(struct fb_info *info)
 	struct drm_framebuffer *fb = fb_helper->fb;
 	struct drm_gem_object *gobj = drm_gem_fb_get_obj(fb, 0);
 
+	drm_fb_helper_fini(fb_helper);
+
 	drm_framebuffer_unregister_private(fb);
 	drm_framebuffer_cleanup(fb);
 	kfree(fb);
 	fb_helper->fb = NULL;
 
 	loonggpufb_destroy_pinned_object(gobj);
-
-	drm_fb_helper_fini(fb_helper);
+	drm_client_release(&fb_helper->client);
+	drm_fb_helper_unprepare(fb_helper);
+	kfree(fb_helper);
 }
 
 static struct fb_ops loonggpufb_ops = {
@@ -258,7 +261,6 @@ static int loonggpufb_create(struct drm_fb_helper *helper,
 	DRM_INFO("screen_base 0x%llX\n", (u64)info->screen_base);
 	DRM_INFO("screen_size 0x%lX\n", info->screen_size);
 
-	vga_switcheroo_client_fb_set(adev->pdev, info);
 	return 0;
 
 err_drm_framebuffer_unregister_private:
@@ -276,56 +278,100 @@ static const struct drm_fb_helper_funcs loonggpu_fb_helper_funcs = {
 	.fb_probe = loonggpufb_create,
 };
 
-int loonggpu_fbdev_init(struct loonggpu_device *adev)
+static void loonggpu_fbdev_client_unregister(struct drm_client_dev *client)
 {
-	struct drm_fb_helper *fb_helper;
-	int bpp_sel = 32;
-	int ret;
+	struct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);
+	struct drm_device *dev = fb_helper->dev;
+	struct loonggpu_device *rdev = dev->dev_private;
+
+	if (fb_helper->info) {
+		vga_switcheroo_client_fb_set(rdev->pdev, NULL);
+		drm_fb_helper_unregister_info(fb_helper);
+	} else {
+		drm_client_release(&fb_helper->client);
+		drm_fb_helper_unprepare(fb_helper);
+		kfree(fb_helper);
+	}
+}
 
-	/* don't init fbdev on hw without DCE */
-	if (!adev->mode_info.mode_config_initialized)
-		return 0;
+static int loonggpu_fbdev_client_restore(struct drm_client_dev *client)
+{
+	drm_fb_helper_lastclose(client->dev);
+	vga_switcheroo_process_delayed_switch();
 
-	/* don't init fbdev if there are no connectors */
-	if (list_empty(&adev->ddev->mode_config.connector_list))
-		return 0;
+	return 0;
+}
 
-	fb_helper = kzalloc(sizeof(*fb_helper), GFP_KERNEL);
-	if (!fb_helper)
-		return -ENOMEM;
+static int loonggpu_fbdev_client_hotplug(struct drm_client_dev *client) {
+	struct drm_fb_helper *fb_helper = drm_fb_helper_from_client(client);
+	struct drm_device *dev = client->dev;
+	struct loonggpu_device *rdev = dev->dev_private;
+	int ret;
 
-	lg_drm_fb_helper_prepare(adev->ddev, fb_helper,
-				bpp_sel, &loonggpu_fb_helper_funcs);
+	if (dev->fb_helper)
+		return drm_fb_helper_hotplug_event(dev->fb_helper);
 
-	ret = lg_drm_fb_helper_init(adev->ddev, fb_helper,
-				 LOONGGPUFB_CONN_LIMIT);
+	ret = drm_fb_helper_init(dev, fb_helper);
 	if (ret)
-		goto free;
+		goto err_drm_err;
+
+	if (!drm_drv_uses_atomic_modeset(dev))
+		drm_helper_disable_unused_functions(dev);
 
-	lg_drm_fb_helper_single_add_all_connectors(fb_helper);
 	ret = drm_fb_helper_initial_config(fb_helper);
 	if (ret)
-		goto fini;
+		goto err_drm_fb_helper_fini;
+
+	vga_switcheroo_client_fb_set(rdev->pdev, fb_helper->info);
 
 	return 0;
 
-fini:
+err_drm_fb_helper_fini:
 	drm_fb_helper_fini(fb_helper);
-free:
-	drm_fb_helper_unprepare(fb_helper);
-	kfree(fb_helper);
+err_drm_err:
+	drm_err(dev, "Failed to setup loonggpu fbdev emulation (ret = %d)\n",
+		ret);
 	return ret;
 }
 
-void loonggpu_fbdev_fini(struct loonggpu_device *adev)
+static const struct drm_client_funcs loonggpu_fbdev_client_funcs = {
+	.owner = THIS_MODULE,
+	.unregister = loonggpu_fbdev_client_unregister,
+	.restore = loonggpu_fbdev_client_restore,
+	.hotplug = loonggpu_fbdev_client_hotplug,
+};
+
+void loonggpu_fbdev_setup(struct loonggpu_device *adev)
 {
-	if (!adev->ddev->fb_helper)
+	struct drm_fb_helper *fb_helper;
+	int bpp_sel = 32;
+	int ret;
+
+	fb_helper = kzalloc(sizeof(*fb_helper), GFP_KERNEL);
+	if (!fb_helper)
 		return;
 
-	drm_fb_helper_unregister_info(adev->ddev->fb_helper);
-	drm_fb_helper_unprepare(adev->ddev->fb_helper);
-	kfree(adev->ddev->fb_helper);
-	adev->ddev->fb_helper = NULL;
+	lg_drm_fb_helper_prepare(adev->ddev, fb_helper,
+				bpp_sel, &loonggpu_fb_helper_funcs);
+
+	ret = drm_client_init(adev->ddev, &fb_helper->client, "loonggpu-fbdev",
+			      &loonggpu_fbdev_client_funcs);
+	if (ret) {
+		drm_err(adev->ddev, "Failed to register client: %d\n", ret);
+		goto err_drm_client_init;
+	}
+
+	ret = loonggpu_fbdev_client_hotplug(&fb_helper->client);
+	if (ret)
+		drm_dbg_kms(adev->ddev, "client hotplug ret = %d\n", ret);
+
+	drm_client_register(&fb_helper->client);
+
+	return;
+
+err_drm_client_init:
+	drm_fb_helper_unprepare(fb_helper);
+	kfree(fb_helper);
 }
 
 void loonggpu_fbdev_set_suspend(struct loonggpu_device *adev, int state)
-- 
2.52.0

